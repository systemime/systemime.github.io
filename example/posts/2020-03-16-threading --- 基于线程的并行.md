---
title: threading --- 基于线程的并行
subtitle: 文章暂存
author: systemime
date: 2020-03-16
header_img: /img/in-post/2020-10-29/header.jpg
catalog: true
tags:
  - python
---

欢迎来到我的世界.

<!-- more -->

> [https://docs.python.org/zh-cn/3.7/library/threading.html](https://docs.python.org/zh-cn/3.7/library/threading.html)


<br />**源代码:** [Lib/threading.py](https://github.com/python/cpython/tree/3.7/Lib/threading.py)

---

这个模块在较低级的模块 [`_thread`](https://docs.python.org/zh-cn/3.7/library/_thread.html#module-_thread) 基础上建立较高级的线程接口。参见： [`queue`](https://docs.python.org/zh-cn/3.7/library/queue.html#module-queue) 模块。<br />_在 3.7 版更改: _这个模块曾经为可选项，但现在总是可用。<br />注解<br /> <br />虽然他们没有在下面列出，这个模块仍然支持Python 2.x系列的这个模块下以 `camelCase` （驼峰法）命名的方法和函数。<br />这个模块定义了以下函数：<br />`threading.``active_count`()<br />返回当前存活的线程类 [`Thread`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread) 对象。返回的计数等于 [`enumerate()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.enumerate) 返回的列表长度。<br />`threading.``current_thread`()<br />返回当前对应调用者的控制线程的 [`Thread`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread) 对象。如果调用者的控制线程不是利用 [`threading`](https://docs.python.org/zh-cn/3.7/library/threading.html#module-threading) 创建，会返回一个功能受限的虚拟线程对象。<br />`threading.``get_ident`()<br />返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。<br />**_3.3 新版功能._**<br />`threading.``enumerate`()<br />以列表形式返回当前所有存活的 [`Thread`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread) 对象。 该列表包含守护线程，[`current_thread()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.current_thread) 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。<br />`threading.``main_thread`()<br />返回主 [`Thread`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread) 对象。一般情况下，主线程是Python解释器开始时创建的线程。<br />**_3.4 新版功能._**<br />`threading.``settrace`(_func_)<br />为所有 [`threading`](https://docs.python.org/zh-cn/3.7/library/threading.html#module-threading) 模块开始的线程设置追踪函数。在每个线程的 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法被调用前，_func_ 会被传递给 [`sys.settrace()`](https://docs.python.org/zh-cn/3.7/library/sys.html#sys.settrace) 。<br />
<br />`threading.``setprofile`(_func_)<br />为所有 [`threading`](https://docs.python.org/zh-cn/3.7/library/threading.html#module-threading) 模块开始的线程设置性能测试函数。在每个线程的 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法被调用前，_func_ 会被传递给 [`sys.setprofile()`](https://docs.python.org/zh-cn/3.7/library/sys.html#sys.setprofile) 。<br />
<br />`threading.``stack_size`([_size_])<br />返回创建线程时用的堆栈大小。可选参数 _size_ 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 _size_ 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 错误。如果指定的堆栈大小不合法，会抛出 [`ValueError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#ValueError) 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。<br />
<br />[适用于](https://docs.python.org/zh-cn/3.7/library/intro.html#availability): Windows，具有 POSIX 线程的系统。<br />
<br />这个模块同时定义了以下常量：<br />`threading.``TIMEOUT_MAX`<br />阻塞函数（ [`Lock.acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire), [`RLock.acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.RLock.acquire), [`Condition.wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait), ...）中形参 _timeout_ 允许的最大值。传入超过这个值的 timeout 会抛出 [`OverflowError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#OverflowError) 异常。<br />**_3.2 新版功能._**<br />这个模块定义了许多类，详见以下部分。<br />该模块的设计基于 Java的线程模型。 但是，在Java里面，锁和条件变量是每个对象的基础特性，而在Python里面，这些被独立成了单独的对象。 Python 的 [`Thread`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread) 类只是 Java 的 Thread 类的一个子集；目前还没有优先级，没有线程组，线程还不能被销毁、停止、暂停、恢复或中断。 Java 的 Thread 类的静态方法在实现时会映射为模块级函数。<br />下述方法的执行都是原子性的。
<a name="CLSCH"></a>
## 线程本地数据
线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 [`local`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.local) （或者一个子类型）的实例并在实例中储存属性：<br />mydata = threading.local()<br />mydata.x = 1<br />在不同的线程中，实例的值会不同。<br />_class _`threading.``local`<br />一个代表线程本地数据的类。<br />更多相关细节和大量示例，参见 `_threading_local` 模块的文档。<br />
<a name="sjUJR"></a>
## 线程对象
The [`Thread`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread) class represents an activity that is run in a separate thread of control. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) method in a subclass. No other methods (except for the constructor) should be overridden in a subclass. In other words, _only_ override the `__init__()` and [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) methods of this class.<br />当线程对象一但被创建，其活动一定会因调用线程的 [`start()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.start) 方法开始。这会在独立的控制线程调用 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法。<br />一旦线程活动开始，该线程会被认为是 '存活的' 。当它的 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法终结了（不管是正常的还是抛出未被处理的异常），就不是'存活的'。 [`is_alive()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.is_alive) 方法用于检查线程是否存活。<br />其他线程可以调用一个线程的 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 方法。这会阻塞调用该方法的线程，直到被调用 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 方法的线程终结。<br />线程有名字。名字可以传递给构造函数，也可以通过 [`name`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.name) 属性读取或者修改。<br />一个线程可以被标记成一个“守护线程”。 这个标志的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。 初始值继承于创建线程。 这个标志可以通过 [`daemon`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.daemon) 特征属性或者 _daemon_ 构造器参数来设置。<br />注解<br /> <br />守护线程在程序关闭时会突然关闭。他们的资源（例如已经打开的文档，数据库事务等等）可能没有被正确释放。如果你想你的线程正常停止，设置他们成为非守护模式并且使用合适的信号机制，例如： [`Event`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event)。<br />有个 "主线程" 对象；这对应Python程序里面初始的控制线程。它不是一个守护线程。<br />"虚拟线程对象" 是可以被创建的。这些是对应于“外部线程”的线程对象，它们是在线程模块外部启动的控制线程，例如直接来自C代码。虚拟线程对象功能受限；他们总是被认为是存活的和守护模式，不能被 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 。因为无法检测外来线程的终结，它们永远不会被删除。<br />_class _`threading.``Thread`(_group=None_, _target=None_, _name=None_, _args=()_, _kwargs={}_, _*_, _daemon=None_)<br />调用这个构造函数时，必需带有关键字参数。参数如下：<br />_group_ 应该为 `None`；为了日后扩展 `ThreadGroup` 类实现而保留。<br />_target_ 是用于 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法调用的可调用对象。默认是 `None`，表示不需要调用任何方法。<br />_name_ 是线程名称。默认情况下，由 "Thread-_N_" 格式构成一个唯一的名称，其中 _N_ 是小的十进制数。<br />_args_ 是用于调用目标函数的参数元组。默认是 `()`。<br />_kwargs_ 是用于调用目标函数的关键字参数字典。默认是 `{}`。<br />如果不是 `None`，_daemon_ 参数将显式地设置该线程是否为守护模式。 如果是 `None` (默认值)，线程将继承当前线程的守护模式属性。<br />如果子类型重载了构造函数，它一定要确保在做任何事前，先发起调用基类构造器(`Thread.__init__()`)。<br />_在 3.3 版更改: _加入 _daemon_ 参数。<br />`start`()<br />开始线程活动。<br />它在一个线程里最多只能被调用一次。它安排对象的 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法在一个独立的控制进程中调用。<br />如果同一个线程对象中调用这个方法的次数大于一次，会抛出 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 。<br />`run`()<br />代表线程活动的方法。<br />你可以在子类型里重载这个方法。 标准的 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法会对作为 _target_ 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 _args_ 和 _kwargs_ 参数分别获取的位置和关键字参数。<br />`join`(_timeout=None_)<br />等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 的线程终结 -- 不管是正常终结还是抛出未处理异常 -- 或者直到发生超时，超时选项是可选的。<br />当 _timeout_ 参数存在而且不是 `None` 时，它应该是一个用于指定操作超时的以秒为单位的浮点数（或者分数）。因为 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 总是返回 `None` ，所以你一定要在 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 后调用 [`is_alive()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.is_alive) 才能判断是否发生超时 -- 如果线程仍然存活，则 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 超时。<br />当 _timeout_ 参数不存在或者是 `None` ，这个操作会阻塞直到线程终结。<br />一个线程可以被 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 很多次。<br />如果尝试加入当前线程会导致死锁， [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 会引起 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 异常。如果尝试 [`join()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.join) 一个尚未开始的线程，也会抛出相同的异常。<br />`name`<br />只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。 初始名称由构造函数设置。<br />`getName`()`setName`()<br />旧的 [`name`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.name) 取值/设值 API；直接当做特征属性使用它。<br />`ident`<br />这个线程的 '线程标识符'，如果线程尚未开始则为 `None` 。这是个非零整数。参见 [`get_ident()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.get_ident) 函数。当一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。<br />`is_alive`()<br />返回线程是否存活。<br />当 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法刚开始直到 [`run()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.run) 方法刚结束，这个方法返回 `True` 。模块函数 [`enumerate()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.enumerate) 返回包含所有存活线程的列表。<br />`daemon`<br />一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 [`start()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.start) 前设置好，不然会抛出 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 [`daemon`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.daemon) = `False`。<br />当没有存活的非守护线程时，整个Python程序才会退出。<br />`isDaemon`()`setDaemon`()<br />旧的 [`name`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread.name) 取值/设值 API；建议直接当做特征属性使用它。<br />**CPython implementation detail:** CPython下，因为 [Global Interpreter Lock](https://docs.python.org/zh-cn/3.7/glossary.html#term-global-interpreter-lock)，一个时刻只有一个线程可以执行Python代码（尽管如此，某些性能导向的库可能会克服这个限制）。如果你想让你的应用更好的利用多核计算机的计算性能，推荐你使用 [`multiprocessing`](https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#module-multiprocessing) 或者 [`concurrent.futures.ProcessPoolExecutor`](https://docs.python.org/zh-cn/3.7/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor) 。但是如果你想同时运行多个I/O绑定任务，线程仍然是一个合适的模型。<br />
<a name="xszZl"></a>
## 锁对象
原始锁是一个在锁定时不属于特定线程的同步基元组件。在Python中，它是能用的最低级的同步基元组件，由 [`_thread`](https://docs.python.org/zh-cn/3.7/library/_thread.html#module-_thread) 扩展模块直接实现。<br />原始锁处于 "锁定" 或者 "非锁定" 两种状态之一。它被创建时为非锁定状态。它有两个基本方法， [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire) 和 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) 。当状态为非锁定时， [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire) 将状态改为 锁定 并立即返回。当状态是锁定时， [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire) 将阻塞至其他线程调用 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) 将其改为非锁定状态，然后 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire) 调用重置其为锁定状态并返回。 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) 只在锁定状态下调用； 它将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError)  异常。<br />锁同样支持 [上下文管理协议](https://docs.python.org/zh-cn/3.7/library/threading.html#with-locks)。<br />当多个线程在 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire) 等待状态转变为未锁定被阻塞，然后 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) 重置状态为未锁定时，只有一个线程能继续执行；至于哪个等待线程继续执行没有定义，并且会根据实现而不同。<br />所有方法的执行都是原子性的。<br />_class _`threading.``Lock`<br />实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。<br />需要注意的是 `Lock` 其实是一个工厂函数，返回平台支持的具体锁类中最有效的版本的实例。<br />`acquire`(_blocking=True_, _timeout=-1_)<br />可以阻塞或非阻塞地获得锁。<br />当调用时参数 _blocking_ 设置为 `True` （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 `True` 。<br />在参数 _blocking_ 被设置为 `False` 的情况下调用，将不会发生阻塞。如果调用时 _blocking_ 设为 `True` 会阻塞，并立即返回 `False` ；否则，将锁锁定并返回 `True`。<br />当浮点型 _timeout_ 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 _timeout_ 设定的秒数。_timeout_ 参数被设置为 `-1` 时将无限等待。当 _blocking_ 为 false 时，_timeout_ 指定的值将被忽略。<br />如果成功获得锁，则返回 `True`，否则返回 `False` (例如发生 _超时_ 的时候)。<br />_在 3.2 版更改: _新的 _timeout_ 形参。<br />_在 3.2 版更改: _现在如果底层线程实现支持，则可以通过POSIX上的信号中断锁的获取。<br />`release`()<br />释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。<br />当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。<br />在未锁定的锁调用时，会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 异常。<br />没有返回值。<br />`locked`()<br />如果获得了锁则返回真值。<br />
<a name="u02Z9"></a>
## 递归锁对象
重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 "所属线程" 和 "递归等级" 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。<br />若要锁定锁，线程调用其 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.RLock.acquire) 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) 方法。 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire)/[`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) 对可以嵌套；只有最终 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) (最外面一对的 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.release) ) 将锁解开，才能让其他线程继续处理 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock.acquire) 阻塞。<br />递归锁也支持 [上下文管理协议](https://docs.python.org/zh-cn/3.7/library/threading.html#with-locks)。<br />_class _`threading.``RLock`<br />此类实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。<br />需要注意的是 `RLock` 其实是一个工厂函数，返回平台支持的具体递归锁类中最有效的版本的实例。<br />`acquire`(_blocking=True_, _timeout=-1_)<br />可以阻塞或非阻塞地获得锁。

- 当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。
- 当发起调用时将 _blocking_ 参数设为真值，则执行与无参数调用时一样的操作，然后返回 `True`。
- 当发起调用时将 _blocking_ 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 `False`；在其他情况下，执行与无参数调用时一样的操作，然后返回 `True`。
- 当发起调用时将浮点数的 _timeout_ 参数设为正值时，只要无法获得锁，将最多阻塞 _timeout_ 所指定的秒数。 如果已经获得锁则返回 `True`，如果超时则返回假值。

**_在 3.2 版更改: _新的 _timeout_ 形参。**<br />`release`()<br />释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。<br />只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 异常。<br />没有返回值。<br />
<a name="uN14Q"></a>
## 条件对象
条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。锁是条件对象的一部分，你不必单独地跟踪它。<br />条件变量服从 [上下文管理协议](https://docs.python.org/zh-cn/3.7/library/threading.html#with-locks)：使用 `with` 语句会在它包围的代码块内获取关联的锁。 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.acquire) 和 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.release) 方法也能调用关联锁的相关方法。<br />其它方法必须在持有关联的锁的情况下调用。 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) 方法释放锁，然后阻塞直到其它线程调用 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 方法或 [`notify_all()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify_all) 方法唤醒它。一旦被唤醒， [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) 方法重新获取锁并返回。它也可以指定超时时间。<br />The [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) method wakes up one of the threads waiting for the condition variable, if any are waiting. The [`notify_all()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify_all) method wakes up all threads waiting for the condition variable.<br />注意： [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 方法和 [`notify_all()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify_all) 方法并不会释放锁，这意味着被唤醒的线程不会立即从它们的 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) 方法调用中返回，而是会在调用了 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 方法或 [`notify_all()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify_all) 方法的线程最终放弃了锁的所有权后返回。<br />使用条件变量的典型编程风格是将锁用于同步某些共享状态的权限，那些对状态的某些特定改变感兴趣的线程，它们重复调用 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) 方法，直到看到所期望的改变发生；而对于修改状态的线程，它们将当前状态改变为可能是等待者所期待的新状态后，调用 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 方法或者 [`notify_all()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify_all) 方法。例如，下面的代码是一个通用的无限缓冲区容量的生产者-消费者情形：<br />_# Consume one item_<br />**with** cv:<br />    **while** **not** an_item_is_available():<br />        cv.wait()<br />    get_an_available_item()<br />
<br />_# Produce one item_<br />**with** cv:<br />    make_an_item_available()<br />    cv.notify()<br />使用 `while` 循环检查所要求的条件成立与否是有必要的，因为 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) 方法可能要经过不确定长度的时间后才会返回，而此时导致 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 方法调用的那个条件可能已经不再成立。这是多线程编程所固有的问题。 [`wait_for()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait_for) 方法可自动化条件检查，并简化超时计算。<br />_# Consume an item_<br />**with** cv:<br />    cv.wait_for(an_item_is_available)<br />    get_an_available_item()<br />选择 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 还是 [`notify_all()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify_all) ，取决于一次状态改变是只能被一个还是能被多个等待线程所用。例如在一个典型的生产者-消费者情形中，添加一个项目到缓冲区只需唤醒一个消费者线程。<br />_class _`threading.``Condition`(_lock=None_)<br />实现条件变量对象的类。一个条件变量对象允许一个或多个线程在被其它线程所通知之前进行等待。<br />如果给出了非 `None` 的 _lock_ 参数，则它必须为 [`Lock`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock) 或者 [`RLock`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.RLock) 对象，并且它将被用作底层锁。否则，将会创建新的 [`RLock`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.RLock) 对象，并将其用作底层锁。<br />_在 3.3 版更改: _从工厂函数变为类。<br />`acquire`(_*args_)<br />请求底层锁。此方法调用底层锁的相应方法，返回值是底层锁相应方法的返回值。<br />`release`()<br />释放底层锁。此方法调用底层锁的相应方法。没有返回值。<br />`wait`(_timeout=None_)<br />等待直到被通知或发生超时。如果线程在调用此方法时没有获得锁，将会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 异常。<br />这个方法释放底层锁，然后阻塞，直到在另外一个线程中调用同一个条件变量的 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 或 [`notify_all()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify_all) 唤醒它，或者直到可选的超时发生。一旦被唤醒或者超时，它重新获得锁并返回。<br />当提供了 _timeout_ 参数且不是 `None` 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。<br />当底层锁是个 [`RLock`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.RLock) ，不会使用它的 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.release) 方法释放锁，因为当它被递归多次获取时，实际上可能无法解锁。相反，使用了 [`RLock`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.RLock) 类的内部接口，即使多次递归获取它也能解锁它。 然后，在重新获取锁时，使用另一个内部接口来恢复递归级别。<br />返回 `True` ，除非提供的 _timeout_ 过期，这种情况下返回 `False`。<br />_在 3.2 版更改: _很明显，方法总是返回 `None`。<br />`wait_for`(_predicate_, _timeout=None_)<br />等待，直到条件计算为真。 _predicate_ 应该是一个可调用对象而且它的返回值可被解释为一个布尔值。可以提供 _timeout_ 参数给出最大等待时间。<br />这个实用方法会重复地调用 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) 直到满足判断式或者发生超时。返回值是判断式最后一个返回值，而且如果方法发生超时会返回 `False` 。<br />忽略超时功能，调用此方法大致相当于编写:<br />**while** **not** predicate():<br />    cv.wait()<br />因此，规则同样适用于 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) ：锁必须在被调用时保持获取，并在返回时重新获取。 随着锁定执行判断式。<br />_3.2 新版功能._<br />`notify`(_n=1_)<br />默认唤醒一个等待这个条件的线程。如果调用线程在没有获得锁的情况下调用这个方法，会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 异常。<br />这个方法唤醒最多 _n_ 个正在等待这个条件变量的线程；如果没有线程在等待，这是一个空操作。<br />当前实现中，如果至少有 _n_ 个线程正在等待，准确唤醒 _n_ 个线程。但是依赖这个行为并不安全。未来，优化的实现有时会唤醒超过 _n_ 个线程。<br />注意：被唤醒的线程实际上不会返回它调用的 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.wait) ，直到它可以重新获得锁。因为 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 不会释放锁，只有它的调用者应该这样做。<br />`notify_all`()<br />唤醒所有正在等待这个条件的线程。这个方法行为与 [`notify()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition.notify) 相似，但并不只唤醒单一线程，而是唤醒所有等待线程。如果调用线程在调用这个方法时没有获得锁，会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 异常。<br />
<a name="ufdvA"></a>
## 信号量对象
这是计算机科学史上最古老的同步原语之一，早期的荷兰科学家 Edsger W. Dijkstra 发明了它。（他使用名称 `P()` 和 `V()` 而不是 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.acquire) 和 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.release) ）。<br />一个信号量管理一个内部计数器，该计数器因 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.acquire) 方法的调用而递减，因 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.release) 方法的调用而递增。 计数器的值永远不会小于零；当 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.acquire) 方法发现计数器为零时，将会阻塞，直到其它线程调用 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.release) 方法。<br />信号量对象也支持 [上下文管理协议](https://docs.python.org/zh-cn/3.7/library/threading.html#with-locks) 。<br />_class _`threading.``Semaphore`(_value=1_)<br />该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.release) 方法的调用次数减去 [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.acquire) 的调用次数再加上一个初始值。如果需要， [`acquire()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.acquire) 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 _value_ 的值时，默认为1。<br />可选参数 _value_ 赋予内部计数器初始值，默认值为 `1` 。如果 _value_ 被赋予小于0的值，将会引发 [`ValueError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#ValueError) 异常。<br />_在 3.3 版更改: _从工厂函数变为类。<br />`acquire`(_blocking=True_, _timeout=None_)<br />获取一个信号量。<br />在不带参数的情况下调用时：

- 如果在进入时内部计数器的值大于零，则将其减一并立即返回 `True`。<br />
- 如果在进入时内部计数器的值为零，则将会阻塞直到被对 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.release) 的调用唤醒。 一旦被唤醒（并且计数器的值大于 0），则将计数器减 1 并返回 `True`。 每次对 [`release()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore.release) 的调用将只唤醒一个线程。 线程被唤醒的次序是不可确定的。<br />

当发起调用时将 _blocking_ 设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 `False`；在其他情况下，执行与无参数调用时一样的操作，然后返回 `True`。<br />当发起调用时如果 _timeout_ 不为 `None`，则它将阻塞最多 _timeout_ 秒。 请求在此时段时未能成功完成获取则将返回 `False`。 在其他情况下返回 `True`。<br />_在 3.2 版更改: _新的 _timeout_ 形参。<br />`release`()<br />释放一个信号量，将内部计数器的值增加1。当计数器原先的值为0且有其它线程正在等待它再次大于0时，唤醒正在等待的线程。<br />_class _`threading.``BoundedSemaphore`(_value=1_)<br />该类实现有界信号量。有界信号量通过检查以确保它当前的值不会超过初始值。如果超过了初始值，将会引发 [`ValueError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#ValueError) 异常。在大多情况下，信号量用于保护数量有限的资源。如果信号量被释放的次数过多，则表明出现了错误。没有指定时， _value_ 的值默认为1。<br />_在 3.3 版更改: _从工厂函数变为类。<br />
<a name="cUe1v"></a>
### [`Semaphore`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore) 例子
信号量通常用于保护数量有限的资源，例如数据库服务器。在资源数量固定的任何情况下，都应该使用有界信号量。在生成任何工作线程前，应该在主线程中初始化信号量。<br />maxconnections = 5<br />_# ..._<br />pool_sema = BoundedSemaphore(value=maxconnections)<br />工作线程生成后，当需要连接服务器时，这些线程将调用信号量的 acquire 和 release 方法：<br />**with** pool_sema:<br />    conn = connectdb()<br />    **try**:<br />        _# ... use connection ..._<br />    **finally**:<br />        conn.close()<br />使用有界信号量能减少这种编程错误：信号量的释放次数多于其请求次数。<br />
<a name="4YEUk"></a>
## 事件对象
这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。<br />一个事件对象管理一个内部标志，调用 [`set()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.set) 方法可将其设置为true，调用 [`clear()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.clear) 方法可将其设置为false，调用 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.wait) 方法将进入阻塞直到标志为true。<br />_class _`threading.``Event`<br />实现事件对象的类。事件对象管理一个内部标志，调用 [`set()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.set) 方法可将其设置为true。调用 [`clear()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.clear) 方法可将其设置为false。调用 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.wait) 方法将进入阻塞直到标志为true。这个标志初始时为false。<br />_在 3.3 版更改: _从工厂函数变为类。<br />`is_set`()<br />当且仅当内部旗标为时返回 `True`。<br />`set`()<br />将内部标志设置为true。所有正在等待这个事件的线程将被唤醒。当标志为true时，调用 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.wait) 方法的线程不会被被阻塞。<br />`clear`()<br />将内部标志设置为false。之后调用 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.wait) 方法的线程将会被阻塞，直到调用 [`set()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.set) 方法将内部标志再次设置为true。<br />`wait`(_timeout=None_)<br />阻塞线程直到内部变量为true。如果调用时内部标志为true，将立即返回。否则将阻塞线程，直到调用 [`set()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Event.set) 方法将标志设置为true或者发生可选的超时。<br />当提供了timeout参数且不是 `None` 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。<br />当且仅当内部旗标在等待调用之前或者等待开始之后被设为真值时此方法将返回 `True`，也就是说，它将总是返回 `True` 除非设定了超时且操作发生了超时。<br />_在 3.1 版更改: _很明显，方法总是返回 `None`。<br />
<a name="Hz4Sy"></a>
## 定时器对象
此类表示一个操作应该在等待一定的时间之后运行 --- 相当于一个定时器。 [`Timer`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Timer) 类是 [`Thread`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Thread) 类的子类，因此可以像一个自定义线程一样工作。<br />与线程一样，通过调用 `start()` 方法启动定时器。而 [`cancel()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Timer.cancel) 方法可以停止计时器（在计时结束前）， 定时器在执行其操作之前等待的时间间隔可能与用户指定的时间间隔不完全相同。<br />例如<br />**def** hello():<br />    print("hello, world")<br />
<br />t = Timer(30.0, hello)<br />t.start()  _# after 30 seconds, "hello, world" will be printed_<br />_class _`threading.``Timer`(_interval_, _function_, _args=None_, _kwargs=None_)<br />创建一个定时器，在经过 _interval_ 秒的间隔事件后，将会用参数 _args_ 和关键字参数 _kwargs_ 调用 _function_。如果 _args_ 为 `None` （默认值），则会使用一个空列表。如果 _kwargs_ 为 `None` （默认值），则会使用一个空字典。<br />_在 3.3 版更改: _从工厂函数变为类。<br />`cancel`()<br />停止定时器并取消执行计时器将要执行的操作。仅当计时器仍处于等待状态时有效。
<a name="TWRLR"></a>
## 栅栏对象
_3.2 新版功能._<br />栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Barrier.wait) 方法后将阻塞，直到所有线程都调用了 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Barrier.wait) 方法。此时所有线程将被同时释放。<br />栅栏对象可以被多次使用，但进程的数量不能改变。<br />这是一个使用简便的方法实现客户端进程与服务端进程同步的例子：<br />b = Barrier(2, timeout=5)<br />
<br />**def** server():<br />    start_server()<br />    b.wait()<br />    **while** **True**:<br />        connection = accept_connection()<br />        process_server_connection(connection)<br />
<br />**def** client():<br />    b.wait()<br />    **while** **True**:<br />        connection = make_connection()<br />        process_client_connection(connection)<br />_class _`threading.``Barrier`(_parties_, _action=None_, _timeout=None_)<br />创建一个需要 _parties_ 个线程的栅栏对象。如果提供了可调用的 _action_ 参数，它会在所有线程被释放时在其中一个线程中自动调用。 _timeout_ 是默认的超时时间，如果没有在 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Barrier.wait) 方法中指定超时时间的话。<br />`wait`(_timeout=None_)<br />冲出栅栏。当栅栏中所有线程都已经调用了这个函数，它们将同时被释放。如果提供了 _timeout_ 参数，这里的 _timeout_ 参数优先于创建栅栏对象时提供的 _timeout_ 参数。<br />函数返回值是一个整数，取值范围在0到 _parties_ -- 1，在每个线程中的返回值不相同。可用于从所有线程中选择唯一的一个线程执行一些特别的工作。例如：<br />i = barrier.wait()<br />**if** i == 0:<br />    _# Only one thread needs to print this_<br />    print("passed the barrier")<br />如果创建栅栏对象时在构造函数中提供了 _action_ 参数，它将在其中一个线程释放前被调用。如果此调用引发了异常，栅栏对象将进入损坏态。<br />如果发生了超时，栅栏对象将进入破损态。<br />如果栅栏对象进入破损态，或重置栅栏时仍有线程等待释放，将会引发 [`BrokenBarrierError`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.BrokenBarrierError) 异常。<br />`reset`()<br />重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 [`BrokenBarrierError`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.BrokenBarrierError) 异常。<br />注意使用此函数时，如果有某些线程状态未知，则可能需其它的同步来确保线程已被释放。如果栅栏进入了破损态，最好废弃它并新建一个栅栏。<br />`abort`()<br />使栅栏进入破损态。这将导致所有已经调用和未来调用的 [`wait()`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Barrier.wait) 方法中引发 [`BrokenBarrierError`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.BrokenBarrierError) 异常。使用这个方法的一种情况是需要中止程序以避免死锁。<br />更好的方式是：创建栅栏时提供一个合理的超时时间，来自动避免某个线程出错。<br />`parties`<br />冲出栅栏所需要的线程数量。<br />`n_waiting`<br />当前时刻正在栅栏中阻塞的线程数量。<br />`broken`<br />一个布尔值，值为 `True` 表明栅栏为破损态。<br />_exception _`threading.``BrokenBarrierError`<br />异常类，是 [`RuntimeError`](https://docs.python.org/zh-cn/3.7/library/exceptions.html#RuntimeError) 异常的子类，在 [`Barrier`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Barrier) 对象重置时仍有线程阻塞时和对象进入破损态时被引发。<br />
<a name="VJET5"></a>
## 在 `with` 语句中使用锁、条件和信号量
这个模块提供的带有 `acquire()` 和 `release()` 方法的对象，可以被用作 [`with`](https://docs.python.org/zh-cn/3.7/reference/compound_stmts.html#with) 语句的上下文管理器。当进入语句块时 `acquire()` 方法会被调用，退出语句块时 `release()` 会被调用。因此，以下片段:<br />**with** some_lock:<br />    _# do something..._<br />相当于:<br />some_lock.acquire()<br />**try**:<br />    _# do something..._<br />**finally**:<br />    some_lock.release()<br />现在 [`Lock`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Lock) 、 [`RLock`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.RLock) 、 [`Condition`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Condition) 、 [`Semaphore`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.Semaphore) 和 [`BoundedSemaphore`](https://docs.python.org/zh-cn/3.7/library/threading.html#threading.BoundedSemaphore) 对象可以用作 [`with`](https://docs.python.org/zh-cn/3.7/reference/compound_stmts.html#with) 语句的上下文管理器。
