---
title: python异步编程之asyncio（百万并发）
subtitle: 文章暂存
author: systemime
date: 2020-03-16
header_img: /img/in-post/2020-10-29/header.jpg
catalog: true
tags:
  - python
---

欢迎来到我的世界.

<!-- more -->

前言：python由于GIL（全局锁）的存在，不能发挥多核的优势，其性能一直饱受诟病。然而在IO密集型的网络编程里，异步处理比同步处理能提升成百上千倍的效率，弥补了python性能方面的短板，如最新的微服务框架japronto，resquests per second可达百万级。<br /> <br />python还有一个优势是库（第三方库）极为丰富，运用十分方便。asyncio是python3.4版本引入到标准库，python2x没有加这个库，毕竟python3x才是未来啊，哈哈！python3.5又加入了async/await特性。<br /> <br />在学习asyncio之前，我们先来理清楚**同步/异步的概念**：<br />**·同步**是指完成事务的逻辑，先执行第一个事务，如果阻塞了，会一直等待，直到这个事务完成，再执行第二个事务，顺序执行。。。<br />****·**异步**是和同步相对的，异步是指在处理调用这个事务的之后，不会等待这个事务的处理结果，直接处理第二个事务去了，通过状态、通知、回调来通知调用者处理结果。<br /> 
<a name="vwmRO"></a>
## 一、asyncio
下面通过举例来对比**同步代码和异步代码编写方面的差异**，其次看下两者性能上的差距，我们使用sleep(1)模拟耗时1秒的io操作。<br /> **·****同步代码**：<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431486-fda866b6-2e1a-4961-8f8b-7f9a187673f6.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />import time<br />
<br />def hello():<br />    time.sleep(1)<br />
<br />def run():<br />    for i in range(5):<br />        hello()<br />        print('Hello World:%s' % time.time())  # 任何伟大的代码都是从Hello World 开始的！<br />if __name__ == '__main__':<br />    run()<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431452-4ae61dc0-708c-4912-9ae3-88c9eb978156.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />输出：（间隔约是1s）<br />Hello World:1527595175.4728756<br />Hello World:1527595176.473001<br />Hello World:1527595177.473494<br />Hello World:1527595178.4739306<br />Hello World:1527595179.474482<br /> **·****异步代码**：<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431480-6c40a6a2-2764-4e5d-aa94-f66ff07aaec3.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />import time<br />import asyncio<br />
<br /># 定义异步函数<br />async def hello():<br />    asyncio.sleep(1)<br />    print('Hello World:%s' % time.time())<br />
<br />def run():<br />    for i in range(5):<br />        loop.run_until_complete(hello())<br />
<br />loop = asyncio.get_event_loop()<br />if __name__ =='__main__':<br />    run()

![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431479-d1824051-8642-4916-8580-60e48c2d633e.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br /> 输出：<br />Hello World:1527595104.8338501<br />Hello World:1527595104.8338501<br />Hello World:1527595104.8338501<br />Hello World:1527595104.8338501<br />Hello World:1527595104.8338501<br /> <br />async def 用来定义异步函数，其内部有异步操作。每个线程有一个事件循环，**主线程调用asyncio.get_event_loop()时会创建事件循环，你需要把异步的任务丢给这个循环的run_until_complete()方法**，事件循环会安排协同程序的执行。<br /> 
<a name="maLn9"></a>
## 二、aiohttp
　　如果需要并发http请求怎么办呢，通常是用requests，但requests是同步的库，如果想异步的话需要引入aiohttp。**这里引入一个类，from aiohttp import ClientSession，首先要建立一个session对象，然后用session对象去打开网页**。session可以进行多项操作，比如post, get, put, head等。<br />基本用法：<br />async with ClientSession() as session:<br />    async with session.get(url) as response:<br /> <br />aiohttp异步实现的例子：<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972432382-6119906f-e6f3-48af-8bfe-a2fba0904a1b.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />import asyncio<br />from aiohttp import ClientSession<br />
<br />
<br />tasks = []<br />url = "[https://www.baidu.com/{}](https://www.baidu.com/%7B%7D)"<br />async def hello(url):<br />    async with ClientSession() as session:<br />        async with session.get(url) as response:<br />            response = await response.read()<br />            print(response)<br />
<br />if __name__ == '__main__':<br />    loop = asyncio.get_event_loop()<br />    loop.run_until_complete(hello(url))<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431451-76656faa-d983-4dc7-8f01-7222aaaf2cc5.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br /> <br />首先async def 关键字定义了这是个异步函数，await 关键字加在需要等待的操作前面，response.read()等待request响应，是个耗IO操作。然后使用ClientSession类发起http请求。<br /> <br />多链接异步访问<br />如果我们需要请求多个URL该怎么办呢，同步的做法访问多个URL只需要加个for循环就可以了。但异步的实现方式并没那么容易，**在之前的基础上需要将hello()包装在asyncio的Future对象中，然后将Future对象列表作为任务传递给事件循环**。<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431488-dd915f1b-d0c4-482a-a48c-1bd87c5b337d.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />import time<br />import asyncio<br />from aiohttp import ClientSession<br />
<br />tasks = []<br />url = "[https://www.baidu.com/{}](https://www.baidu.com/%7B%7D)"<br />async def hello(url):<br />    async with ClientSession() as session:<br />        async with session.get(url) as response:<br />            response = await response.read()<br />#            print(response)<br />            print('Hello World:%s' % time.time())<br />
<br />def run():<br />    for i in range(5):<br />        task = asyncio.ensure_future(hello(url.format(i)))<br />        tasks.append(task)<br />
<br />
<br />if __name__ == '__main__':<br />    loop = asyncio.get_event_loop()<br />    run()<br />    loop.run_until_complete(asyncio.wait(tasks))

![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431477-2468fa85-427d-4e40-a615-5c7b23a36ed0.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br /> 输出：<br />Hello World:1527754874.8915546<br />Hello World:1527754874.899039<br />Hello World:1527754874.90004<br />Hello World:1527754874.9095392<br />Hello World:1527754874.9190395<br /> <br /> 收集http响应<br />好了，上面介绍了访问不同链接的异步实现方式，但是我们只是发出了请求，如果要把响应一一收集到一个列表中，最后保存到本地或者打印出来要怎么实现呢，**可通过asyncio.gather(*tasks)将响应全部收集起来**，具体通过下面实例来演示。<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431502-38de28af-55cf-4f64-8d6c-62836468b4d6.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />import time<br />import asyncio<br />from aiohttp import ClientSession<br />
<br />tasks = []<br />url = "[https://www.baidu.com/{}](https://www.baidu.com/%7B%7D)"<br />async def hello(url):<br />    async with ClientSession() as session:<br />        async with session.get(url) as response:<br />#            print(response)<br />            print('Hello World:%s' % time.time())<br />            return await response.read()<br />
<br />def run():<br />    for i in range(5):<br />        task = asyncio.ensure_future(hello(url.format(i)))<br />        tasks.append(task)<br />    result = loop.run_until_complete(asyncio.gather(*tasks))<br />    print(result)<br />
<br />if __name__ == '__main__':<br />    loop = asyncio.get_event_loop()<br />    run()<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431497-54cb898e-63e8-43b1-9e12-510679d3a505.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br /> 输出：<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431476-b9818fe6-0a5b-4b7a-a744-fed1cca84431.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />Hello World:1527765369.0785167<br />Hello World:1527765369.0845182<br />Hello World:1527765369.0910277<br />Hello World:1527765369.0920424<br />Hello World:1527765369.097017<br />[b'<!DOCTYPE html>\r\n<!--STATUS OK-->\r\n<html>\r\n<head>\r\n......<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431491-2d9d3b32-9259-4466-8c79-ef4b8cde112a.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br /> <br />异常解决<br />假如你的并发达到2000个，程序会报错：ValueError: too many file descriptors in select()。报错的原因字面上看是 Python 调取的 select 对打开的文件有最大数量的限制，这个其实是操作系统的限制，linux打开文件的最大数默认是1024，windows默认是509，超过了这个值，程序就开始报错。这里我们有**三种方法解决**这个问题：<br />**1.限制并发数量**。（一次不要塞那么多任务，或者限制最大并发数量）<br />**2.使用回调的方式**。<br />**3.修改操作系统打开文件数的最大限制，在系统里有个配置文件可以修改默认值，具体步骤不再说明了。**<br />不修改系统默认配置的话，个人推荐限制并发数的方法，设置并发数为500，处理速度更快。<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431541-b65a474c-8d08-4ea3-b7df-a673696e8d71.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br />#coding:utf-8<br />import time,asyncio,aiohttp<br />
<br />
<br />url = '[https://www.baidu.com/](https://www.baidu.com/)'<br />async def hello(url,semaphore):<br />    async with semaphore:<br />        async with aiohttp.ClientSession() as session:<br />            async with session.get(url) as response:<br />                return await response.read()<br />
<br />
<br />async def run():<br />    semaphore = asyncio.Semaphore(500) # 限制并发量为500<br />    to_get = [hello(url.format(),semaphore) for _ in range(1000)] #总共1000任务<br />    await asyncio.wait(to_get)<br />
<br />
<br />if __name__ == '__main__':<br />#    now=lambda :time.time()<br />    loop = asyncio.get_event_loop()<br />    loop.run_until_complete(run())<br />    loop.close()<br />![](https://cdn.nlark.com/yuque/0/2020/gif/663138/1596972431639-9e616c90-12d6-4d2c-97fb-f8c0e5412f92.gif#align=left&display=inline&height=20&margin=%5Bobject%20Object%5D&originHeight=20&originWidth=20&size=0&status=done&style=none&width=20)<br /> 
